<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>세포 분열 시뮬레이션</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f0f0f0;
            cursor: pointer;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .cell {
            width: 50px;
            height: 50px;
            background-color: #ffffff; /* 흰색 배경 */
            border: 2px solid #000000; /* 검은색 테두리 */
            border-radius: 50%; /* 원형 모양 */
            position: absolute;
            transform-origin: center;
            transition: transform 0.5s ease, opacity 0.5s ease, left 0.7s ease, top 0.7s ease;
            opacity: 0;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .cell.active {
            opacity: 1;
            animation: cellDivide 0.7s forwards;
        }

        .cell::before {
            content: '';
            width: 10px; /* 검은 점 크기 */
            height: 10px;
            background-color: #000000; /* 검은색 점 */
            border-radius: 50%; /* 점을 원형으로 */
            position: absolute;
        }

        @keyframes cellDivide {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }

        @keyframes cellSplit {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container" onclick="divideAllCells()">
        <div class="cell active" id="cell1" data-label="1" data-division-count="0" style="left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>
    </div>
    <script>
        const cellSize = 50; // 세포 크기
        const divisionDistance = cellSize / 2; // 세포 분열 시 이동 거리
        let cellCount = 1;

        function divideAllCells() {
            const cells = document.querySelectorAll('.cell');
            const newCells = [];

            // 모든 세포에 대해 분열 수행 (각 세포는 하나의 새로운 세포만 생성)
            cells.forEach(cell => {
                const newCell = divideCell(cell);
                if (newCell) {
                    newCells.push(newCell);
                }
            });

            // 새로 생성된 세포들에 대해 충돌 처리
            newCells.forEach(newCell => {
                handleImmediateCollision(newCell);
            });
        }

        function divideCell(cell) {
            const container = document.querySelector('.container');

            // 부모 세포 정보 가져오기
            const parentLabel = cell.getAttribute('data-label');
            let divisionCount = parseInt(cell.getAttribute('data-division-count')) || 0;

            // 분열 횟수 증가
            divisionCount++;
            cell.setAttribute('data-division-count', divisionCount);

            // 새로운 세포 라벨 생성
            const newLabel = parentLabel + '-' + divisionCount;

            // 부모 세포의 위치 가져오기
            const parentCellRect = cell.getBoundingClientRect();
            const newPosition = {
                x: parentCellRect.left + divisionDistance - container.offsetLeft,
                y: parentCellRect.top - container.offsetTop
            };

            // 새로운 세포 생성 (부모 세포의 오른쪽에 위치)
            return createNewCell(newPosition, container, newLabel);
        }

        function createNewCell(position, container, label) {
            const newCell = document.createElement('div');
            newCell.className = 'cell';
            newCell.id = `cell${++cellCount}`;
            newCell.setAttribute('data-label', label);
            newCell.setAttribute('data-division-count', 0);

            // 초기 위치 설정 및 애니메이션 추가
            newCell.style.left = `${position.x}px`;
            newCell.style.top = `${position.y}px`;
            newCell.classList.add('active');
            newCell.style.animation = 'cellSplit 0.7s forwards'; // 분열 애니메이션 설정
            container.appendChild(newCell);

            // 새로 생성된 세포에 클릭 이벤트 추가
            newCell.addEventListener('click', function(event) {
                event.stopPropagation();
                divideAllCells();
            });

            // 지속적인 충돌 감지 시작
            setInterval(() => {
                handleContinuousCollision(newCell);
            }, 100); // 0.1초마다 충돌 검사

            return newCell;
        }

        function handleImmediateCollision(newCell) {
            const cells = document.querySelectorAll('.cell');
            checkAndResolveCollision(newCell, cells);
        }

        function handleContinuousCollision(newCell) {
            const cells = document.querySelectorAll('.cell');
            checkAndResolveCollision(newCell, cells);
        }

        function checkAndResolveCollision(newCell, cells) {
            const newCellRect = newCell.getBoundingClientRect();

            cells.forEach(cell => {
                if (cell !== newCell) {
                    const cellRect = cell.getBoundingClientRect();
                    const dx = cellRect.left - newCellRect.left;
                    const dy = cellRect.top - newCellRect.top;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < cellSize) { // 겹쳐있는 경우를 감지
                        // 반대 방향으로 밀어내기
                        const angle = Math.atan2(dy, dx);
                        const moveDistance = cellSize - distance; // 세포 크기만큼 밀어냄

                        const moveX = Math.cos(angle) * moveDistance;
                        const moveY = Math.sin(angle) * moveDistance;

                        // 위치 업데이트
                        const currentLeft = parseFloat(newCell.style.left);
                        const currentTop = parseFloat(newCell.style.top);

                        newCell.style.left = `${currentLeft + moveX}px`;
                        newCell.style.top = `${currentTop + moveY}px`;

                        // 기존 세포도 밀어내기 처리
                        const reverseAngle = angle + Math.PI;
                        const existingMoveX = Math.cos(reverseAngle) * moveDistance;
                        const existingMoveY = Math.sin(reverseAngle) * moveDistance;
                        cell.style.left = `${parseFloat(cell.style.left) + existingMoveX}px`;
                        cell.style.top = `${parseFloat(cell.style.top) + existingMoveY}px`;
                    }
                }
            });
        }
    </script>
</body>
</html>
